"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MidwayWSFramework = void 0;
const core_1 = require("@midwayjs/core");
const http = require("http");
const util_1 = require("util");
const debug = (0, util_1.debuglog)('midway:debug');
const WebSocket = require("ws");
let MidwayWSFramework = class MidwayWSFramework extends core_1.BaseFramework {
    constructor() {
        super(...arguments);
        this.connectionMiddlewareManager = this.createMiddlewareManager();
    }
    configure() {
        return this.configService.getConfiguration('webSocket');
    }
    applicationInitialize(options) {
        this.configurationOptions.noServer = true;
        const opts = Object.assign({}, this.configurationOptions, { port: null });
        this.app = new WebSocket.Server(opts);
        this.defineApplicationProperties({
            useConnectionMiddleware: (middleware) => {
                return this.useConnectionMiddleware(middleware);
            },
            getConnectionMiddleware: () => {
                return this.getConnectionMiddleware();
            },
        });
    }
    async afterContainerReady(options) {
        await this.loadMidwayController();
    }
    async run() {
        var _a;
        let server;
        if (!this.configurationOptions.port) {
            server = this.applicationContext.get(core_1.HTTP_SERVER_KEY);
            this.logger.info('[midway:ws] WebSocket server find shared http server and will be attach.');
        }
        else {
            server = (_a = this.configurationOptions.server) !== null && _a !== void 0 ? _a : http.createServer();
        }
        server.on('upgrade', (request, socket, head) => {
            this.app.handleUpgrade(request, socket, head, ws => {
                this.app.emit('connection', ws, request);
            });
        });
        this.server = server;
        if (this.configurationOptions.port) {
            await new Promise(resolve => {
                server.listen(this.configurationOptions.port, () => {
                    this.logger.info(`[midway:ws] WebSocket server port = ${this.configurationOptions.port} start success.`);
                    if (this.configurationOptions.enableServerHeartbeatCheck) {
                        this.startHeartBeat();
                    }
                    resolve();
                });
            });
        }
    }
    async beforeStop() {
        return new Promise(resolve => {
            this.app.close(() => {
                setTimeout(() => {
                    resolve();
                }, 1000);
            });
            this.server.close();
        });
    }
    getFrameworkType() {
        return core_1.MidwayFrameworkType.WS;
    }
    async loadMidwayController() {
        // create room
        const controllerModules = (0, core_1.listModule)(core_1.WS_CONTROLLER_KEY);
        if (controllerModules.length > 0) {
            // ws just one namespace
            await this.addNamespace(controllerModules[0]);
        }
    }
    async addNamespace(target) {
        var _a, _b;
        const controllerOption = (0, core_1.getClassMetadata)(core_1.WS_CONTROLLER_KEY, target);
        const controllerMiddleware = (_a = controllerOption.routerOptions.middleware) !== null && _a !== void 0 ? _a : [];
        const controllerConnectionMiddleware = (_b = controllerOption.routerOptions.connectionMiddleware) !== null && _b !== void 0 ? _b : [];
        this.app.on('connection', async (socket, request) => {
            var _a;
            socket.isAlive = true;
            socket.on('error', error => {
                this.logger.error(`socket got error: ${error}`);
            });
            socket.on('pong', () => {
                socket.isAlive = true;
            });
            // create request context
            this.app.createAnonymousContext(socket);
            socket.requestContext.registerObject('socket', socket);
            socket.app = this.app;
            // run connection middleware
            const connectFn = await this.middlewareService.compose([
                ...this.connectionMiddlewareManager,
                ...controllerConnectionMiddleware,
            ], this.app);
            await connectFn(socket);
            const wsEventInfos = (0, core_1.getClassMetadata)(core_1.WS_EVENT_KEY, target);
            // 存储方法对应的响应处理
            const methodMap = {};
            if (wsEventInfos.length) {
                for (const wsEventInfo of wsEventInfos) {
                    methodMap[wsEventInfo.propertyName] = methodMap[wsEventInfo.propertyName] || { responseEvents: [] };
                    const controller = await socket.requestContext.getAsync(target);
                    // on connection
                    if (wsEventInfo.eventType === core_1.WSEventTypeEnum.ON_CONNECTION) {
                        try {
                            const fn = await this.middlewareService.compose([
                                ...(((_a = wsEventInfo === null || wsEventInfo === void 0 ? void 0 : wsEventInfo.eventOptions) === null || _a === void 0 ? void 0 : _a.middleware) || []),
                                async (ctx, next) => {
                                    const isPassed = await this.app
                                        .getFramework()
                                        .runGuard(ctx, target, wsEventInfo.propertyName);
                                    if (!isPassed) {
                                        throw new core_1.MidwayInvokeForbiddenError(wsEventInfo.propertyName, target);
                                    }
                                    // eslint-disable-next-line prefer-spread
                                    return controller[wsEventInfo.propertyName].apply(controller, [socket, request]);
                                },
                            ], this.app);
                            const result = await fn(socket);
                            await this.bindSocketResponse(result, socket, wsEventInfo.propertyName, methodMap);
                        }
                        catch (err) {
                            this.logger.error(err);
                        }
                    }
                    else if (wsEventInfo.eventType === core_1.WSEventTypeEnum.ON_MESSAGE) {
                        // on user custom event
                        socket.on(wsEventInfo.messageEventName, async (...args) => {
                            debug('[ws]: got message', wsEventInfo.messageEventName, args);
                            try {
                                const result = await (await this.applyMiddleware(async (ctx, next) => {
                                    var _a;
                                    // add controller middleware
                                    const fn = await this.middlewareService.compose([
                                        ...controllerMiddleware,
                                        ...(((_a = wsEventInfo === null || wsEventInfo === void 0 ? void 0 : wsEventInfo.eventOptions) === null || _a === void 0 ? void 0 : _a.middleware) || []),
                                        async (ctx, next) => {
                                            // eslint-disable-next-line prefer-spread
                                            return controller[wsEventInfo.propertyName].apply(controller, args);
                                        },
                                    ], this.app);
                                    return await fn(ctx, next);
                                }))(socket);
                                if (typeof args[args.length - 1] === 'function') {
                                    // ack
                                    args[args.length - 1](result);
                                }
                                else {
                                    // emit
                                    await this.bindSocketResponse(result, socket, wsEventInfo.propertyName, methodMap);
                                }
                            }
                            catch (error) {
                                this.logger.error(error);
                            }
                        });
                    }
                    else if (wsEventInfo.eventType === core_1.WSEventTypeEnum.ON_DISCONNECTION) {
                        // on socket disconnect
                        socket.on('close', async (reason) => {
                            try {
                                const result = await controller[wsEventInfo.propertyName].apply(controller, [reason]);
                                await this.bindSocketResponse(result, socket, wsEventInfo.propertyName, methodMap);
                            }
                            catch (err) {
                                this.logger.error(err);
                            }
                        });
                    }
                    else {
                        // 存储每个方法对应的后置响应处理，供后续快速匹配
                        methodMap[wsEventInfo.propertyName].responseEvents.push(wsEventInfo);
                    }
                }
            }
        });
        this.app.on('error', err => {
            this.logger.error('socket server got error', err);
        });
        this.app.on('close', () => {
            if (this.heartBeatInterval) {
                clearInterval(this.heartBeatInterval);
            }
            this.logger.info('socket server close');
        });
    }
    async bindSocketResponse(result, socket, propertyName, methodMap) {
        if (!result)
            return;
        if (methodMap[propertyName]) {
            for (const wsEventInfo of methodMap[propertyName].responseEvents) {
                if (wsEventInfo.eventType === core_1.WSEventTypeEnum.EMIT) {
                    socket.send(formatResult(result));
                }
                else if (wsEventInfo.eventType === core_1.WSEventTypeEnum.BROADCAST) {
                    this.app.clients.forEach(client => {
                        if (client.readyState === WebSocket.OPEN) {
                            client.send(formatResult(result));
                        }
                    });
                }
            }
            if (methodMap[propertyName].responseEvents.length === 0) {
                // no emit decorator
                socket.send(formatResult(result));
            }
        }
        else {
            // just send
            socket.send(formatResult(result));
        }
    }
    getFrameworkName() {
        return 'midway:ws';
    }
    useConnectionMiddleware(middleware) {
        this.connectionMiddlewareManager.insertLast(middleware);
    }
    getConnectionMiddleware() {
        return this.connectionMiddlewareManager;
    }
    startHeartBeat() {
        this.heartBeatInterval = setInterval(() => {
            this.app.clients.forEach((socket) => {
                if (socket.isAlive === false) {
                    debug('[ws]: socket terminate');
                    return socket.terminate();
                }
                socket.isAlive = false;
                socket.ping();
            });
        }, this.configurationOptions.serverHeartbeatInterval);
    }
};
MidwayWSFramework = __decorate([
    (0, core_1.Framework)()
], MidwayWSFramework);
exports.MidwayWSFramework = MidwayWSFramework;
function formatResult(result) {
    return core_1.Types.isObject(result) ? JSON.stringify(result) : result;
}
//# sourceMappingURL=framework.js.map