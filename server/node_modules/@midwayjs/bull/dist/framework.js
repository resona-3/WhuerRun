"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BullFramework = exports.BullQueue = void 0;
const core_1 = require("@midwayjs/core");
const Bull = require("bull");
const constants_1 = require("./constants");
class BullQueue extends Bull {
    constructor(queueName, queueOptions) {
        super(queueName, queueOptions);
    }
    async addJobToQueue(data, options) {
        return this.add(data || {}, options);
    }
    /**
     * @deprecated use addJobToQueue instead
     */
    async runJob(data, options) {
        return this.add(data || {}, options);
    }
    getQueueName() {
        return this.name;
    }
}
exports.BullQueue = BullQueue;
let BullFramework = class BullFramework extends core_1.BaseFramework {
    constructor() {
        super(...arguments);
        this.queueMap = new Map();
    }
    async applicationInitialize(options) {
        this.app = {};
    }
    loadConfig() {
        this.bullDefaultQueueConfig = this.configService.getConfiguration('bull.defaultQueueOptions');
        this.bullDefaultConcurrency = this.configService.getConfiguration('bull.defaultConcurrency');
        this.bullClearRepeatJobWhenStart = this.configService.getConfiguration('bull.clearRepeatJobWhenStart');
    }
    configure() {
        return this.configService.getConfiguration('bull');
    }
    getFrameworkName() {
        return 'bull';
    }
    async run() {
        var _a, _b, _c;
        const processorModules = (0, core_1.listModule)(constants_1.BULL_PROCESSOR_KEY);
        for (const mod of processorModules) {
            const options = (0, core_1.getClassMetadata)(constants_1.BULL_PROCESSOR_KEY, mod);
            const { repeat, delay, ...otherOptions } = (_a = options.jobOptions) !== null && _a !== void 0 ? _a : {};
            const queueOptions = (_b = options.queueOptions) !== null && _b !== void 0 ? _b : {};
            const currentQueue = this.ensureQueue(options.queueName, {
                ...queueOptions,
                defaultJobOptions: otherOptions,
            });
            // clear old repeat job when start
            if (this.bullClearRepeatJobWhenStart) {
                const jobs = await currentQueue.getRepeatableJobs();
                for (const job of jobs) {
                    await currentQueue.removeRepeatableByKey(job.key);
                }
            }
            await this.addProcessor(mod, options.queueName, options.concurrency);
            if ((_c = options.jobOptions) === null || _c === void 0 ? void 0 : _c.repeat) {
                await this.addJobToQueue(options.queueName, {}, options.jobOptions);
            }
        }
    }
    async beforeStop() {
        // loop queueMap and stop all queue
        for (const queue of this.queueMap.values()) {
            await queue.close();
        }
    }
    createQueue(name, queueOptions = {}) {
        const queue = new BullQueue(name, (0, core_1.extend)(true, {}, this.bullDefaultQueueConfig, queueOptions));
        this.queueMap.set(name, queue);
        queue.on('error', err => {
            this.bullLogger.error(err);
        });
        return queue;
    }
    getQueue(name) {
        return this.queueMap.get(name);
    }
    ensureQueue(name, queueOptions = {}) {
        if (!this.queueMap.has(name)) {
            this.createQueue(name, queueOptions);
        }
        return this.queueMap.get(name);
    }
    getQueueList() {
        return Array.from(this.queueMap.values());
    }
    async addProcessor(processor, queueName, concurrency) {
        const queue = typeof queueName === 'string' ? this.queueMap.get(queueName) : queueName;
        queue.process(concurrency !== null && concurrency !== void 0 ? concurrency : this.bullDefaultConcurrency, async (job) => {
            const ctx = this.app.createAnonymousContext({
                jobId: job.id,
                job,
                from: processor,
            });
            try {
                ctx.logger.info(`start process job ${job.id} from ${processor.name}`);
                const isPassed = await this.app
                    .getFramework()
                    .runGuard(ctx, processor, 'execute');
                if (!isPassed) {
                    throw new core_1.MidwayInvokeForbiddenError('execute', processor);
                }
                const service = await ctx.requestContext.getAsync(processor);
                const fn = await this.applyMiddleware(async (ctx) => {
                    return await core_1.Utils.toAsyncFunction(service.execute.bind(service))(job.data, job);
                });
                const result = await Promise.resolve(await fn(ctx));
                ctx.logger.info(`complete process job ${job.id} from ${processor.name}`);
                return result;
            }
            catch (err) {
                ctx.logger.error(err);
                return Promise.reject(err);
            }
        });
    }
    async addJobToQueue(queueName, jobData, options) {
        const queue = this.queueMap.get(queueName);
        if (queue) {
            return await queue.addJobToQueue(jobData, options);
        }
    }
    /**
     * @deprecated use addJob instead
     */
    async runJob(queueName, jobData, options) {
        return this.addJobToQueue(queueName, jobData, options);
    }
    async getJob(queueName, jobName) {
        const queue = this.queueMap.get(queueName);
        if (queue) {
            return queue.getJob(jobName);
        }
    }
};
__decorate([
    (0, core_1.Logger)('bullLogger'),
    __metadata("design:type", Object)
], BullFramework.prototype, "bullLogger", void 0);
BullFramework = __decorate([
    (0, core_1.Framework)()
], BullFramework);
exports.BullFramework = BullFramework;
//# sourceMappingURL=framework.js.map