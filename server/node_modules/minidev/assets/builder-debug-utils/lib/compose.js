"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.composeAssetsByCompileMode = void 0;
const interface_1 = require("./interface");
const config_1 = require("./config");
function concatSource(...argv) {
    return argv.join('\n');
}
function composeAssetsByCompileMode(assetsMap, options) {
    let composeMethod;
    switch (options.mode) {
        case interface_1.ECompileModeType.Preview:
            composeMethod = composeAssets4Preview;
            break;
        case interface_1.ECompileModeType.Remote:
            composeMethod = composeAssets4Remote;
            break;
        case interface_1.ECompileModeType.Remotex:
            composeMethod = composeAssets4Remotex;
            break;
        case interface_1.ECompileModeType.RemotexLite:
            composeMethod = composeAssets4RemotexLite;
            break;
        case interface_1.ECompileModeType.RemoteBoatman:
            composeMethod = composeAssets4RemoteBoatman;
            break;
        default:
            throw new Error(`[${config_1.libName}] unknown compile mode: ${options.mode}`);
    }
    return composeMethod(assetsMap, options);
}
exports.composeAssetsByCompileMode = composeAssetsByCompileMode;
function composeAssets4Preview(assetsMap, options) {
    if (options.target === interface_1.ECompileTargetType.Cube) {
        return {};
    }
    else {
        return {
            workerTop: assetsMap.bugmeWPreview,
            webTop: `window.__BUGME_ENV__='preview';${assetsMap.bugmeRPreview}`,
            htmlTop: `<script>window.__BUGME_ENV__='preview';${assetsMap.bugmeRPreview}</script>`,
        };
    }
}
function toHtmlTop(text) {
    return `<script snapshot-delete="">${text !== null && text !== void 0 ? text : ''}</script>`;
}
function composeAssets4Remote(assetsMap, options) {
    return {
        webTop: assetsMap.bugmeRRemote,
        htmlTop: toHtmlTop(assetsMap.bugmeRRemote),
    };
}
function composeAssets4Remotex(assetsMap, options) {
    return options.compilePlugin
        ? {
            workerTop: assetsMap.bugmeWRemote,
            pluginWorkerTop: assetsMap.tyroAgent,
            webTop: assetsMap.bugmeRRemote,
            htmlTop: toHtmlTop(assetsMap.bugmeRRemote),
        }
        : {
            workerTop: concatSource(assetsMap.tyroAgent || '', assetsMap.bugmeWRemote || ''),
            webTop: assetsMap.bugmeRRemote,
            htmlTop: toHtmlTop(assetsMap.bugmeRRemote),
        };
}
function composeAssets4RemotexLite(assetsMap, options) {
    return {
        workerTop: concatSource('var __BUGME_CONSOLE_ENABLE__=true;', assetsMap.bugmeWRemote || ''),
        webTop: assetsMap.bugmeRRemote,
        htmlTop: toHtmlTop(assetsMap.bugmeRRemote),
    };
}
function composeAssets4RemoteBoatman(assetsMap, options) {
    if (options.target === interface_1.ECompileTargetType.Cube) {
        return {};
    }
    else {
        // Boatman 模式下 tinybugme 会跟随 boatman_mini 一起注入到 worker 中
        const points = {
            webTop: assetsMap.bugmeRRemote,
            htmlTop: toHtmlTop(assetsMap.bugmeRRemote),
        };
        // 插件模式下 boatman_mini 注入到插件上下文中，tinybugme 不会生效，因此需要额外注入到宿主 worker 中
        if (options.compilePlugin) {
            points.workerTop = assetsMap.bugmeWRemote;
        }
        return points;
    }
}
